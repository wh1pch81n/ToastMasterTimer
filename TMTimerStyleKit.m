//
//  TMTimerStyleKit.m
//  Toastmaster Timer
//
//  Created by Derrick Ho on 8/24/14.
//  Copyright (c) 2014 dnthome. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "TMTimerStyleKit.h"


@implementation TMTimerStyleKit

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawTimerGaugeMediumWithFrame: (CGRect)frame minSeconds: (CGFloat)minSeconds maxSeconds: (CGFloat)maxSeconds elapsedSeconds: (CGFloat)elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* gaugeOutline = [UIColor colorWithRed: 0.333 green: 0.278 blue: 0.278 alpha: 1];
    UIColor* gaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* lowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* mediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* highPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* gaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* white = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];

    //// Variable Declarations
    CGFloat midSeconds = (minSeconds + maxSeconds) / 2.0;
    CGFloat pressure = elapsedSeconds / (maxSeconds + 30);
    CGFloat ppressure = pressure < 0 ? 0 : (pressure > 1 ? 1 : pressure);
    CGFloat angle = -270 * ppressure + 135;
    UIColor* limitingColor = elapsedSeconds <= 0 ? white : (elapsedSeconds < minSeconds ? gaugeNormal : (elapsedSeconds < midSeconds ? lowPressureColor : (elapsedSeconds < maxSeconds ? mediumPressureColor : highPressureColor)));
    UIColor* overTimeColor = elapsedSeconds < maxSeconds + 30 ? gaugeOutline : gaugeOutlineOverTime;

    //// Perimeter Drawing
    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame) + 10, CGRectGetMinY(frame) + 10, CGRectGetWidth(frame) - 20, CGRectGetHeight(frame) - 20)];
    [UIColor.whiteColor setFill];
    [perimeterPath fill];
    [overTimeColor setStroke];
    perimeterPath.lineWidth = 6;
    [perimeterPath stroke];


    //// mark Drawing
    UIBezierPath* markPath = UIBezierPath.bezierPath;
    [markPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 84.39)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 76.61) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 262.54, CGRectGetMinY(frame) + 82.24) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 262.54, CGRectGetMinY(frame) + 78.76)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 252.61, CGRectGetMinY(frame) + 76.61) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 258.24, CGRectGetMinY(frame) + 74.46) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 254.76, CGRectGetMinY(frame) + 74.46)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 252.61, CGRectGetMinY(frame) + 84.39) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 250.46, CGRectGetMinY(frame) + 78.76) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 250.46, CGRectGetMinY(frame) + 82.24)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 84.39) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 254.76, CGRectGetMinY(frame) + 86.54) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 258.24, CGRectGetMinY(frame) + 86.54)];
    [markPath closePath];
    [gaugeOutline setStroke];
    markPath.lineWidth = 6;
    [markPath stroke];


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.68694 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.83512 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.69397 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.83120 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.30423 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.82904 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.56808 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.90137 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.42139 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.89935 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.28155 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81103 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.29707 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.82475 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.28155 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81103 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.30159 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.78661 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.32667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75833 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.35257 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76962 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.32667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75833 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.34144 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76415 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.64000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77333 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.41882 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.80221 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.57166 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.79964 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.67667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76000 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.64848 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77007 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.67667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76000 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69813 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.78683 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame))];
    [bezier5Path closePath];
    [limitingColor setFill];
    [bezier5Path fill];
    [overTimeColor setStroke];
    bezier5Path.lineWidth = 6;
    [bezier5Path stroke];


    //// ticks Drawing
    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 241.74, CGRectGetMinY(frame) + 200.52)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 224.75, CGRectGetMinY(frame) + 74.25) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 264.63, CGRectGetMinY(frame) + 160.43) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 258.96, CGRectGetMinY(frame) + 108.47)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 76.25, CGRectGetMinY(frame) + 74.25) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 183.74, CGRectGetMinY(frame) + 33.25) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 117.26, CGRectGetMinY(frame) + 33.25)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 59.03, CGRectGetMinY(frame) + 200.12) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 42.15, CGRectGetMinY(frame) + 108.36) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 36.41, CGRectGetMinY(frame) + 160.08)];
    [gaugeOutline setStroke];
    ticksPath.lineWidth = 16;
    CGFloat ticksPattern[] = {6, 46};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.70729 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70359 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.75136 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.74672 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.76833 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76333 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.79000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.74667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.76833 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76333 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.77923 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75754 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.83457 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68792 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.80582 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.73069 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.82459 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70569 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.77130 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.23036 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.91635 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.54221 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.89526 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.35433 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.23036 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.23036 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.62193 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.08099 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.37974 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.08099 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.17543 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70205 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.10236 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.35837 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.08405 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.55454 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.19069 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.72667 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.25134 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75033 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.24488 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75632 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.29950 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70464 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.27472 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.72866 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.28980 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.71421 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.31465 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68970 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.29559 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.66294 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.30207 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.67117 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.31571 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.31237 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.21392 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.55919 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.22012 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.40796 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.68929 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.31237 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.41887 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.20921 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.58613 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.20921 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.70619 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.66895 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.78674 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.40982 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.79277 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.56509 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.70111 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.67504 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath closePath];
    [overTimeColor setStroke];
    bezierPath.lineWidth = 6;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, CGRectGetMinX(frame) + 0.50017 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.49704 * CGRectGetHeight(frame));
    CGContextRotateCTM(context, -angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-10.05, 33.89)];
    [gaugeArmPath addLineToPoint: CGPointMake(10.95, 33.89)];
    [gaugeArmPath addLineToPoint: CGPointMake(10.95, -85.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.95, -99.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-10.05, -85.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-10.05, 33.89)];
    [gaugeArmPath closePath];
    [overTimeColor setFill];
    [gaugeArmPath fill];
    [overTimeColor setStroke];
    gaugeArmPath.lineWidth = 6;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame) + 134, CGRectGetMinY(frame) + 134, CGRectGetWidth(frame) - 267, CGRectGetHeight(frame) - 267)];
    [UIColor.whiteColor setFill];
    [turnGearPath fill];
    [gaugeOutline setStroke];
    turnGearPath.lineWidth = 6;
    [turnGearPath stroke];
}

+ (void)drawTimerGaugeSmallWithMinSeconds: (CGFloat)minSeconds maxSeconds: (CGFloat)maxSeconds elapsedSeconds: (CGFloat)elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* gaugeOutline = [UIColor colorWithRed: 0.333 green: 0.278 blue: 0.278 alpha: 1];
    UIColor* gaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* lowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* mediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* highPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* gaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* white = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 1];

    //// Variable Declarations
    CGFloat midSeconds = (minSeconds + maxSeconds) / 2.0;
    CGFloat pressure = elapsedSeconds / (maxSeconds + 30);
    CGFloat ppressure = pressure < 0 ? 0 : (pressure > 1 ? 1 : pressure);
    CGFloat angle = -270 * ppressure + 135;
    UIColor* limitingColor = elapsedSeconds <= 0 ? white : (elapsedSeconds < minSeconds ? gaugeNormal : (elapsedSeconds < midSeconds ? lowPressureColor : (elapsedSeconds < maxSeconds ? mediumPressureColor : highPressureColor)));
    UIColor* overTimeColor = elapsedSeconds < maxSeconds + 30 ? gaugeOutline : gaugeOutlineOverTime;

    //// Perimeter Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);

    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-47, -47, 94, 94)];
    [white setFill];
    [perimeterPath fill];
    [overTimeColor setStroke];
    perimeterPath.lineWidth = 2;
    [perimeterPath stroke];

    CGContextRestoreGState(context);


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(71.5, 84.73)];
    [bezier5Path addCurveToPoint: CGPointMake(68.36, 86.37) controlPoint1: CGPointMake(71.5, 84.73) controlPoint2: CGPointMake(69.05, 86)];
    [bezier5Path addCurveToPoint: CGPointMake(30.73, 85.79) controlPoint1: CGPointMake(56.67, 92.73) controlPoint2: CGPointMake(42.25, 92.54)];
    [bezier5Path addCurveToPoint: CGPointMake(28.5, 84.06) controlPoint1: CGPointMake(30.03, 85.38) controlPoint2: CGPointMake(28.5, 84.06)];
    [bezier5Path addLineToPoint: CGPointMake(30.47, 81.71)];
    [bezier5Path addLineToPoint: CGPointMake(32.94, 79)];
    [bezier5Path addCurveToPoint: CGPointMake(35.48, 80.08) controlPoint1: CGPointMake(32.94, 79) controlPoint2: CGPointMake(34.39, 79.56)];
    [bezier5Path addCurveToPoint: CGPointMake(63.75, 80.44) controlPoint1: CGPointMake(42, 83.21) controlPoint2: CGPointMake(57.03, 82.97)];
    [bezier5Path addCurveToPoint: CGPointMake(67.35, 79.16) controlPoint1: CGPointMake(64.58, 80.13) controlPoint2: CGPointMake(67.35, 79.16)];
    [bezier5Path addLineToPoint: CGPointMake(69.46, 81.74)];
    [bezier5Path addLineToPoint: CGPointMake(71.5, 84.73)];
    [bezier5Path closePath];
    [limitingColor setFill];
    [bezier5Path fill];
    [overTimeColor setStroke];
    bezier5Path.lineWidth = 2;
    [bezier5Path stroke];


    //// ticks Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 51);

    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(30.85, 18.5)];
    [ticksPath addCurveToPoint: CGPointMake(25.1, -25.73) controlPoint1: CGPointMake(38.59, 4.46) controlPoint2: CGPointMake(36.67, -13.74)];
    [ticksPath addCurveToPoint: CGPointMake(-25.1, -25.73) controlPoint1: CGPointMake(11.24, -40.09) controlPoint2: CGPointMake(-11.24, -40.09)];
    [ticksPath addCurveToPoint: CGPointMake(-30.92, 18.36) controlPoint1: CGPointMake(-36.63, -13.78) controlPoint2: CGPointMake(-38.57, 4.34)];
    [white setFill];
    [ticksPath fill];
    [gaugeOutline setStroke];
    ticksPath.lineWidth = 7;
    CGFloat ticksPattern[] = {3, 8};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];

    CGContextRestoreGState(context);


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(69.53, 70.3)];
    [bezierPath addLineToPoint: CGPointMake(71.32, 72.07)];
    [bezierPath addLineToPoint: CGPointMake(75.87, 76.57)];
    [bezierPath addLineToPoint: CGPointMake(77.62, 78.3)];
    [bezierPath addCurveToPoint: CGPointMake(79.86, 76.57) controlPoint1: CGPointMake(77.62, 78.3) controlPoint2: CGPointMake(78.75, 77.7)];
    [bezierPath addCurveToPoint: CGPointMake(84.46, 70.43) controlPoint1: CGPointMake(81.5, 74.9) controlPoint2: CGPointMake(83.43, 72.29)];
    [bezierPath addCurveToPoint: CGPointMake(77.93, 22.69) controlPoint1: CGPointMake(92.91, 55.23) controlPoint2: CGPointMake(90.73, 35.63)];
    [bezierPath addCurveToPoint: CGPointMake(22.07, 22.69) controlPoint1: CGPointMake(62.51, 7.1) controlPoint2: CGPointMake(37.49, 7.1)];
    [bezierPath addCurveToPoint: CGPointMake(16.4, 71.91) controlPoint1: CGPointMake(8.85, 36.05) controlPoint2: CGPointMake(6.96, 56.52)];
    [bezierPath addCurveToPoint: CGPointMake(22.03, 79) controlPoint1: CGPointMake(17.97, 74.48) controlPoint2: CGPointMake(22.03, 79)];
    [bezierPath addCurveToPoint: CGPointMake(24.24, 76.95) controlPoint1: CGPointMake(22.03, 79) controlPoint2: CGPointMake(23.57, 77.57)];
    [bezierPath addCurveToPoint: CGPointMake(29.21, 72.18) controlPoint1: CGPointMake(26.65, 74.69) controlPoint2: CGPointMake(28.21, 73.18)];
    [bezierPath addCurveToPoint: CGPointMake(30.98, 70.3) controlPoint1: CGPointMake(30.77, 70.62) controlPoint2: CGPointMake(30.98, 70.3)];
    [bezierPath addCurveToPoint: CGPointMake(28.81, 67.83) controlPoint1: CGPointMake(30.98, 70.3) controlPoint2: CGPointMake(29.47, 68.69)];
    [bezierPath addCurveToPoint: CGPointMake(30.88, 31.25) controlPoint1: CGPointMake(20.37, 57) controlPoint2: CGPointMake(21.01, 41.22)];
    [bezierPath addCurveToPoint: CGPointMake(69.46, 31.25) controlPoint1: CGPointMake(41.54, 20.48) controlPoint2: CGPointMake(58.81, 20.48)];
    [bezierPath addCurveToPoint: CGPointMake(71.21, 68.46) controlPoint1: CGPointMake(79.53, 41.42) controlPoint2: CGPointMake(80.15, 57.62)];
    [bezierPath addCurveToPoint: CGPointMake(69.53, 70.3) controlPoint1: CGPointMake(70.68, 69.09) controlPoint2: CGPointMake(69.53, 70.3)];
    [bezierPath closePath];
    [overTimeColor setStroke];
    bezierPath.lineWidth = 2;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);
    CGContextRotateCTM(context, -angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-4, 9.94)];
    [gaugeArmPath addLineToPoint: CGPointMake(4, 9.94)];
    [gaugeArmPath addLineToPoint: CGPointMake(4, -27.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.19, -32.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-4, -27.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(-4, 9.94)];
    [gaugeArmPath closePath];
    [overTimeColor setFill];
    [gaugeArmPath fill];
    [overTimeColor setStroke];
    gaugeArmPath.lineWidth = 2;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);

    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-5.5, -5.5, 11, 11)];
    [UIColor.whiteColor setFill];
    [turnGearPath fill];
    [gaugeOutline setStroke];
    turnGearPath.lineWidth = 2;
    [turnGearPath stroke];

    CGContextRestoreGState(context);
}

@end
