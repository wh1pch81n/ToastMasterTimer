//
//  TMTimerStyleKit.m
//  Toastmaster Timer
//
//  Created by Derrick Ho on 8/24/14.
//  Copyright (c) 2014 dnthome. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "TMTimerStyleKit.h"


@implementation TMTimerStyleKit

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawTimerGaugeMediumWithFrame: (CGRect)frame g_minSeconds: (CGFloat)g_minSeconds g_maxSeconds: (CGFloat)g_maxSeconds g_elapsedSeconds: (CGFloat)g_elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* g_GaugeOutline = [UIColor colorWithRed: 0.569 green: 0.517 blue: 0.517 alpha: 1];
    UIColor* g_GaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* g_LowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* g_MediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* g_HighPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* g_GaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* g_white = [UIColor colorWithRed: 1 green: 0.998 blue: 0.998 alpha: 1];
    UIColor* g_clear = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 0];

    //// Variable Declarations
    CGFloat g_midSeconds = (g_minSeconds + g_maxSeconds) / 2.0;
    CGFloat g_pressure = g_elapsedSeconds / (g_maxSeconds + 30);
    CGFloat g_ppressure = g_pressure < 0 ? 0 : (g_pressure > 1 ? 1 : g_pressure);
    CGFloat g_angle = -270 * g_ppressure + 135;
    UIColor* g_limitingColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_minSeconds ? g_GaugeNormal : (g_elapsedSeconds < g_midSeconds ? g_LowPressureColor : (g_elapsedSeconds < g_maxSeconds ? g_MediumPressureColor : g_HighPressureColor)));
    UIColor* g_overTimeColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_maxSeconds + 30 ? g_GaugeOutline : g_GaugeOutlineOverTime);
    UIColor* g_limitingFill = g_elapsedSeconds <= 0 ? g_clear : g_white;

    //// Perimeter Drawing
    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame) + 10, CGRectGetMinY(frame) + 10, CGRectGetWidth(frame) - 20, CGRectGetHeight(frame) - 20)];
    [g_limitingFill setFill];
    [perimeterPath fill];
    [g_limitingColor setStroke];
    perimeterPath.lineWidth = 6;
    [perimeterPath stroke];


    //// mark Drawing
    UIBezierPath* markPath = UIBezierPath.bezierPath;
    [markPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 84.39)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 76.61) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 262.54, CGRectGetMinY(frame) + 82.24) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 262.54, CGRectGetMinY(frame) + 78.76)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 252.61, CGRectGetMinY(frame) + 76.61) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 258.24, CGRectGetMinY(frame) + 74.46) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 254.76, CGRectGetMinY(frame) + 74.46)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 252.61, CGRectGetMinY(frame) + 84.39) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 250.46, CGRectGetMinY(frame) + 78.76) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 250.46, CGRectGetMinY(frame) + 82.24)];
    [markPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 260.39, CGRectGetMinY(frame) + 84.39) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 254.76, CGRectGetMinY(frame) + 86.54) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 258.24, CGRectGetMinY(frame) + 86.54)];
    [markPath closePath];
    [g_overTimeColor setStroke];
    markPath.lineWidth = 6;
    [markPath stroke];


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.68694 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.83512 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.69397 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.83120 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.30423 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.82904 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.56808 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.90137 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.42139 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.89935 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.28155 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81103 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.29707 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.82475 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.28155 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81103 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.30159 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.78661 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.32667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75833 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.35257 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76962 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.32667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75833 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.34144 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76415 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.64000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77333 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.41882 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.80221 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.57166 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.79964 * CGRectGetHeight(frame))];
    [bezier5Path addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.67667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76000 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.64848 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77007 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.67667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76000 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69813 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.78683 * CGRectGetHeight(frame))];
    [bezier5Path addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.71886 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.81799 * CGRectGetHeight(frame))];
    [bezier5Path closePath];
    [g_overTimeColor setFill];
    [bezier5Path fill];
    [g_limitingColor setStroke];
    bezier5Path.lineWidth = 6;
    [bezier5Path stroke];


    //// ticks Drawing
    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 241.74, CGRectGetMinY(frame) + 200.52)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 224.75, CGRectGetMinY(frame) + 74.25) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 264.63, CGRectGetMinY(frame) + 160.43) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 258.96, CGRectGetMinY(frame) + 108.47)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 76.25, CGRectGetMinY(frame) + 74.25) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 183.74, CGRectGetMinY(frame) + 33.25) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 117.26, CGRectGetMinY(frame) + 33.25)];
    [ticksPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 59.03, CGRectGetMinY(frame) + 200.12) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 42.15, CGRectGetMinY(frame) + 108.36) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 36.41, CGRectGetMinY(frame) + 160.08)];
    [g_overTimeColor setStroke];
    ticksPath.lineWidth = 16;
    CGFloat ticksPattern[] = {6, 46};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.70729 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70359 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.75136 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.74672 * CGRectGetHeight(frame))];
    [bezierPath addLineToPoint: CGPointMake(CGRectGetMinX(frame) + 0.76833 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76333 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.79000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.74667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.76833 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.76333 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.77923 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75754 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.83457 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68792 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.80582 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.73069 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.82459 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70569 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.77130 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.23036 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.91635 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.54221 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.89526 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.35433 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.23036 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.23036 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.62193 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.08099 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.37974 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.08099 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.17543 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70205 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.10236 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.35837 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.08405 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.55454 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.19069 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.72667 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.25134 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75033 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.23000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.77000 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.24488 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.75632 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.29950 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.70464 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.27472 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.72866 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.28980 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.71421 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.31465 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68970 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.29559 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.66294 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.31667 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.30207 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.67117 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.31571 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.31237 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.21392 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.55919 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.22012 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.40796 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.68929 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.31237 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.41887 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.20921 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.58613 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.20921 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.70619 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.66895 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.78674 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.40982 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.79277 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.56509 * CGRectGetHeight(frame))];
    [bezierPath addCurveToPoint: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame)) controlPoint1: CGPointMake(CGRectGetMinX(frame) + 0.70111 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.67504 * CGRectGetHeight(frame)) controlPoint2: CGPointMake(CGRectGetMinX(frame) + 0.69000 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.68667 * CGRectGetHeight(frame))];
    [bezierPath closePath];
    [g_limitingColor setStroke];
    bezierPath.lineWidth = 6;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, CGRectGetMinX(frame) + 0.50017 * CGRectGetWidth(frame), CGRectGetMinY(frame) + 0.49704 * CGRectGetHeight(frame));
    CGContextRotateCTM(context, -g_angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-10.05, 33.89)];
    [gaugeArmPath addLineToPoint: CGPointMake(10.95, 33.89)];
    [gaugeArmPath addLineToPoint: CGPointMake(10.95, -85.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.95, -99.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-10.05, -85.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-10.05, 33.89)];
    [gaugeArmPath closePath];
    [g_limitingColor setFill];
    [gaugeArmPath fill];
    [g_limitingColor setStroke];
    gaugeArmPath.lineWidth = 6;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(CGRectGetMinX(frame) + 134, CGRectGetMinY(frame) + 134, CGRectGetWidth(frame) - 267, CGRectGetHeight(frame) - 267)];
    [g_limitingFill setFill];
    [turnGearPath fill];
    [g_overTimeColor setStroke];
    turnGearPath.lineWidth = 6;
    [turnGearPath stroke];
}

+ (void)drawTimerGaugeSmallWithG_minSeconds: (CGFloat)g_minSeconds g_maxSeconds: (CGFloat)g_maxSeconds g_elapsedSeconds: (CGFloat)g_elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* g_GaugeOutline = [UIColor colorWithRed: 0.569 green: 0.517 blue: 0.517 alpha: 1];
    UIColor* g_GaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* g_LowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* g_MediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* g_HighPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* g_GaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* g_white = [UIColor colorWithRed: 1 green: 0.998 blue: 0.998 alpha: 1];
    UIColor* g_clear = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 0];

    //// Variable Declarations
    CGFloat g_midSeconds = (g_minSeconds + g_maxSeconds) / 2.0;
    CGFloat g_pressure = g_elapsedSeconds / (g_maxSeconds + 30);
    CGFloat g_ppressure = g_pressure < 0 ? 0 : (g_pressure > 1 ? 1 : g_pressure);
    CGFloat g_angle = -270 * g_ppressure + 135;
    UIColor* g_limitingColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_minSeconds ? g_GaugeNormal : (g_elapsedSeconds < g_midSeconds ? g_LowPressureColor : (g_elapsedSeconds < g_maxSeconds ? g_MediumPressureColor : g_HighPressureColor)));
    UIColor* g_overTimeColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_maxSeconds + 30 ? g_GaugeOutline : g_GaugeOutlineOverTime);
    UIColor* g_limitingFill = g_elapsedSeconds <= 0 ? g_clear : g_white;

    //// Perimeter Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);

    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-47, -47, 94, 94)];
    [g_limitingFill setFill];
    [perimeterPath fill];
    [g_limitingColor setStroke];
    perimeterPath.lineWidth = 2;
    [perimeterPath stroke];

    CGContextRestoreGState(context);


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(71.5, 84.73)];
    [bezier5Path addCurveToPoint: CGPointMake(68.36, 86.37) controlPoint1: CGPointMake(71.5, 84.73) controlPoint2: CGPointMake(69.05, 86)];
    [bezier5Path addCurveToPoint: CGPointMake(30.73, 85.79) controlPoint1: CGPointMake(56.67, 92.73) controlPoint2: CGPointMake(42.25, 92.54)];
    [bezier5Path addCurveToPoint: CGPointMake(28.5, 84.06) controlPoint1: CGPointMake(30.03, 85.38) controlPoint2: CGPointMake(28.5, 84.06)];
    [bezier5Path addLineToPoint: CGPointMake(30.47, 81.71)];
    [bezier5Path addLineToPoint: CGPointMake(32.94, 79)];
    [bezier5Path addCurveToPoint: CGPointMake(35.48, 80.08) controlPoint1: CGPointMake(32.94, 79) controlPoint2: CGPointMake(34.39, 79.56)];
    [bezier5Path addCurveToPoint: CGPointMake(63.75, 80.44) controlPoint1: CGPointMake(42, 83.21) controlPoint2: CGPointMake(57.03, 82.97)];
    [bezier5Path addCurveToPoint: CGPointMake(67.35, 79.16) controlPoint1: CGPointMake(64.58, 80.13) controlPoint2: CGPointMake(67.35, 79.16)];
    [bezier5Path addLineToPoint: CGPointMake(69.46, 81.74)];
    [bezier5Path addLineToPoint: CGPointMake(71.5, 84.73)];
    [bezier5Path closePath];
    [g_overTimeColor setFill];
    [bezier5Path fill];
    [g_limitingColor setStroke];
    bezier5Path.lineWidth = 2;
    [bezier5Path stroke];


    //// ticks Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 51);

    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(30.85, 18.5)];
    [ticksPath addCurveToPoint: CGPointMake(25.1, -25.73) controlPoint1: CGPointMake(38.59, 4.46) controlPoint2: CGPointMake(36.67, -13.74)];
    [ticksPath addCurveToPoint: CGPointMake(-25.1, -25.73) controlPoint1: CGPointMake(11.24, -40.09) controlPoint2: CGPointMake(-11.24, -40.09)];
    [ticksPath addCurveToPoint: CGPointMake(-30.92, 18.36) controlPoint1: CGPointMake(-36.63, -13.78) controlPoint2: CGPointMake(-38.57, 4.34)];
    [g_overTimeColor setStroke];
    ticksPath.lineWidth = 7;
    CGFloat ticksPattern[] = {3, 8};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];

    CGContextRestoreGState(context);


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(69.53, 70.3)];
    [bezierPath addLineToPoint: CGPointMake(71.32, 72.07)];
    [bezierPath addLineToPoint: CGPointMake(75.87, 76.57)];
    [bezierPath addLineToPoint: CGPointMake(77.62, 78.3)];
    [bezierPath addCurveToPoint: CGPointMake(79.86, 76.57) controlPoint1: CGPointMake(77.62, 78.3) controlPoint2: CGPointMake(78.75, 77.7)];
    [bezierPath addCurveToPoint: CGPointMake(84.46, 70.43) controlPoint1: CGPointMake(81.5, 74.9) controlPoint2: CGPointMake(83.43, 72.29)];
    [bezierPath addCurveToPoint: CGPointMake(77.93, 22.69) controlPoint1: CGPointMake(92.91, 55.23) controlPoint2: CGPointMake(90.73, 35.63)];
    [bezierPath addCurveToPoint: CGPointMake(22.07, 22.69) controlPoint1: CGPointMake(62.51, 7.1) controlPoint2: CGPointMake(37.49, 7.1)];
    [bezierPath addCurveToPoint: CGPointMake(16.4, 71.91) controlPoint1: CGPointMake(8.85, 36.05) controlPoint2: CGPointMake(6.96, 56.52)];
    [bezierPath addCurveToPoint: CGPointMake(22.03, 79) controlPoint1: CGPointMake(17.97, 74.48) controlPoint2: CGPointMake(22.03, 79)];
    [bezierPath addCurveToPoint: CGPointMake(24.24, 76.95) controlPoint1: CGPointMake(22.03, 79) controlPoint2: CGPointMake(23.57, 77.57)];
    [bezierPath addCurveToPoint: CGPointMake(29.21, 72.18) controlPoint1: CGPointMake(26.65, 74.69) controlPoint2: CGPointMake(28.21, 73.18)];
    [bezierPath addCurveToPoint: CGPointMake(30.98, 70.3) controlPoint1: CGPointMake(30.77, 70.62) controlPoint2: CGPointMake(30.98, 70.3)];
    [bezierPath addCurveToPoint: CGPointMake(28.81, 67.83) controlPoint1: CGPointMake(30.98, 70.3) controlPoint2: CGPointMake(29.47, 68.69)];
    [bezierPath addCurveToPoint: CGPointMake(30.88, 31.25) controlPoint1: CGPointMake(20.37, 57) controlPoint2: CGPointMake(21.01, 41.22)];
    [bezierPath addCurveToPoint: CGPointMake(69.46, 31.25) controlPoint1: CGPointMake(41.54, 20.48) controlPoint2: CGPointMake(58.81, 20.48)];
    [bezierPath addCurveToPoint: CGPointMake(71.21, 68.46) controlPoint1: CGPointMake(79.53, 41.42) controlPoint2: CGPointMake(80.15, 57.62)];
    [bezierPath addCurveToPoint: CGPointMake(69.53, 70.3) controlPoint1: CGPointMake(70.68, 69.09) controlPoint2: CGPointMake(69.53, 70.3)];
    [bezierPath closePath];
    [g_limitingColor setStroke];
    bezierPath.lineWidth = 2;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);
    CGContextRotateCTM(context, -g_angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-4, 9.94)];
    [gaugeArmPath addLineToPoint: CGPointMake(4, 9.94)];
    [gaugeArmPath addLineToPoint: CGPointMake(4, -27.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.19, -32.11)];
    [gaugeArmPath addLineToPoint: CGPointMake(-4, -27.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(-4, 9.94)];
    [gaugeArmPath closePath];
    [g_limitingColor setFill];
    [gaugeArmPath fill];
    [g_limitingColor setStroke];
    gaugeArmPath.lineWidth = 2;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 50, 50);

    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-5.5, -5.5, 11, 11)];
    [g_limitingFill setFill];
    [turnGearPath fill];
    [g_overTimeColor setStroke];
    turnGearPath.lineWidth = 2;
    [turnGearPath stroke];

    CGContextRestoreGState(context);
}

+ (void)drawGauge50WithG_minSeconds: (CGFloat)g_minSeconds g_maxSeconds: (CGFloat)g_maxSeconds g_elapsedSeconds: (CGFloat)g_elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* g_GaugeOutline = [UIColor colorWithRed: 0.569 green: 0.517 blue: 0.517 alpha: 1];
    UIColor* g_GaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* g_LowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* g_MediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* g_HighPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* g_GaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* g_white = [UIColor colorWithRed: 1 green: 0.998 blue: 0.998 alpha: 1];
    UIColor* g_clear = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 0];

    //// Variable Declarations
    CGFloat g_midSeconds = (g_minSeconds + g_maxSeconds) / 2.0;
    CGFloat g_pressure = g_elapsedSeconds / (g_maxSeconds + 30);
    CGFloat g_ppressure = g_pressure < 0 ? 0 : (g_pressure > 1 ? 1 : g_pressure);
    CGFloat g_angle = -270 * g_ppressure + 135;
    UIColor* g_limitingColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_minSeconds ? g_GaugeNormal : (g_elapsedSeconds < g_midSeconds ? g_LowPressureColor : (g_elapsedSeconds < g_maxSeconds ? g_MediumPressureColor : g_HighPressureColor)));
    UIColor* g_overTimeColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_maxSeconds + 30 ? g_GaugeOutline : g_GaugeOutlineOverTime);
    UIColor* g_limitingFill = g_elapsedSeconds <= 0 ? g_clear : g_white;

    //// Perimeter Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);

    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-24, -24, 48, 48)];
    [g_limitingFill setFill];
    [perimeterPath fill];
    [g_limitingColor setStroke];
    perimeterPath.lineWidth = 2;
    [perimeterPath stroke];

    CGContextRestoreGState(context);


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(35, 41.39)];
    [bezier5Path addCurveToPoint: CGPointMake(33.58, 42.07) controlPoint1: CGPointMake(35, 41.39) controlPoint2: CGPointMake(33.89, 41.91)];
    [bezier5Path addCurveToPoint: CGPointMake(16.51, 41.83) controlPoint1: CGPointMake(28.28, 44.72) controlPoint2: CGPointMake(21.74, 44.64)];
    [bezier5Path addCurveToPoint: CGPointMake(15.5, 41.11) controlPoint1: CGPointMake(16.19, 41.66) controlPoint2: CGPointMake(15.5, 41.11)];
    [bezier5Path addLineToPoint: CGPointMake(16.39, 40.13)];
    [bezier5Path addLineToPoint: CGPointMake(17.51, 39)];
    [bezier5Path addCurveToPoint: CGPointMake(18.67, 39.45) controlPoint1: CGPointMake(17.51, 39) controlPoint2: CGPointMake(18.17, 39.23)];
    [bezier5Path addCurveToPoint: CGPointMake(31.48, 39.6) controlPoint1: CGPointMake(21.62, 40.75) controlPoint2: CGPointMake(28.44, 40.65)];
    [bezier5Path addCurveToPoint: CGPointMake(33.12, 39.07) controlPoint1: CGPointMake(31.86, 39.47) controlPoint2: CGPointMake(33.12, 39.07)];
    [bezier5Path addLineToPoint: CGPointMake(34.08, 40.14)];
    [bezier5Path addLineToPoint: CGPointMake(35, 41.39)];
    [bezier5Path closePath];
    [g_overTimeColor setFill];
    [bezier5Path fill];
    [g_limitingColor setStroke];
    bezier5Path.lineWidth = 2;
    [bezier5Path stroke];


    //// ticks Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 23, 25);

    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(16.34, 7.5)];
    [ticksPath addCurveToPoint: CGPointMake(13.67, -12.6) controlPoint1: CGPointMake(19.93, 1.12) controlPoint2: CGPointMake(19.04, -7.16)];
    [ticksPath addCurveToPoint: CGPointMake(-9.67, -12.6) controlPoint1: CGPointMake(7.22, -19.13) controlPoint2: CGPointMake(-3.22, -19.13)];
    [ticksPath addCurveToPoint: CGPointMake(-12.37, 7.44) controlPoint1: CGPointMake(-15.03, -7.17) controlPoint2: CGPointMake(-15.93, 1.06)];
    [g_overTimeColor setStroke];
    ticksPath.lineWidth = 4;
    CGFloat ticksPattern[] = {1, 5};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];

    CGContextRestoreGState(context);


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(34.27, 34.78)];
    [bezierPath addLineToPoint: CGPointMake(35.14, 35.64)];
    [bezierPath addLineToPoint: CGPointMake(37.36, 37.82)];
    [bezierPath addLineToPoint: CGPointMake(38.21, 38.66)];
    [bezierPath addCurveToPoint: CGPointMake(39.3, 37.82) controlPoint1: CGPointMake(38.21, 38.66) controlPoint2: CGPointMake(38.76, 38.37)];
    [bezierPath addCurveToPoint: CGPointMake(41.55, 34.84) controlPoint1: CGPointMake(40.1, 37.01) controlPoint2: CGPointMake(41.04, 35.74)];
    [bezierPath addCurveToPoint: CGPointMake(38.36, 11.67) controlPoint1: CGPointMake(45.66, 27.46) controlPoint2: CGPointMake(44.6, 17.95)];
    [bezierPath addCurveToPoint: CGPointMake(11.14, 11.67) controlPoint1: CGPointMake(30.84, 4.11) controlPoint2: CGPointMake(18.66, 4.11)];
    [bezierPath addCurveToPoint: CGPointMake(8.37, 35.56) controlPoint1: CGPointMake(4.7, 18.16) controlPoint2: CGPointMake(3.77, 28.09)];
    [bezierPath addCurveToPoint: CGPointMake(11.12, 39) controlPoint1: CGPointMake(9.14, 36.81) controlPoint2: CGPointMake(11.12, 39)];
    [bezierPath addCurveToPoint: CGPointMake(12.19, 38) controlPoint1: CGPointMake(11.12, 39) controlPoint2: CGPointMake(11.87, 38.31)];
    [bezierPath addCurveToPoint: CGPointMake(14.62, 35.69) controlPoint1: CGPointMake(13.37, 36.91) controlPoint2: CGPointMake(14.13, 36.17)];
    [bezierPath addCurveToPoint: CGPointMake(15.48, 34.78) controlPoint1: CGPointMake(15.38, 34.93) controlPoint2: CGPointMake(15.48, 34.78)];
    [bezierPath addCurveToPoint: CGPointMake(14.42, 33.58) controlPoint1: CGPointMake(15.48, 34.78) controlPoint2: CGPointMake(14.75, 34)];
    [bezierPath addCurveToPoint: CGPointMake(15.43, 15.83) controlPoint1: CGPointMake(10.31, 28.32) controlPoint2: CGPointMake(10.62, 20.67)];
    [bezierPath addCurveToPoint: CGPointMake(34.23, 15.83) controlPoint1: CGPointMake(20.63, 10.6) controlPoint2: CGPointMake(29.04, 10.6)];
    [bezierPath addCurveToPoint: CGPointMake(35.08, 33.88) controlPoint1: CGPointMake(39.14, 20.76) controlPoint2: CGPointMake(39.44, 28.62)];
    [bezierPath addCurveToPoint: CGPointMake(34.27, 34.78) controlPoint1: CGPointMake(34.83, 34.19) controlPoint2: CGPointMake(34.27, 34.78)];
    [bezierPath closePath];
    [g_limitingColor setStroke];
    bezierPath.lineWidth = 2;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);
    CGContextRotateCTM(context, -g_angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-2.91, 7)];
    [gaugeArmPath addLineToPoint: CGPointMake(3.09, 7)];
    [gaugeArmPath addLineToPoint: CGPointMake(3.09, -12.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.23, -15)];
    [gaugeArmPath addLineToPoint: CGPointMake(-2.91, -12.68)];
    [gaugeArmPath addLineToPoint: CGPointMake(-2.91, 7)];
    [gaugeArmPath closePath];
    [g_limitingColor setFill];
    [gaugeArmPath fill];
    [g_limitingColor setStroke];
    gaugeArmPath.lineWidth = 2;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);

    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-5.5, -5.5, 11, 11)];
    [g_limitingFill setFill];
    [turnGearPath fill];
    [g_overTimeColor setStroke];
    turnGearPath.lineWidth = 2;
    [turnGearPath stroke];

    CGContextRestoreGState(context);
}

@end
