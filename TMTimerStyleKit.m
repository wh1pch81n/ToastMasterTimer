//
//  TMTimerStyleKit.m
//  Toastmaster Timer
//
//  Created by Derrick Ho on 8/25/14.
//  Copyright (c) 2014 dnthome. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

#import "TMTimerStyleKit.h"


@implementation TMTimerStyleKit

#pragma mark Initialization

+ (void)initialize
{
}

#pragma mark Drawing Methods

+ (void)drawGauge50WithG_minSeconds: (CGFloat)g_minSeconds g_maxSeconds: (CGFloat)g_maxSeconds g_elapsedSeconds: (CGFloat)g_elapsedSeconds;
{
    //// General Declarations
    CGContextRef context = UIGraphicsGetCurrentContext();

    //// Color Declarations
    UIColor* g_GaugeOutline = [UIColor colorWithRed: 0.569 green: 0.517 blue: 0.517 alpha: 1];
    UIColor* g_GaugeOutlineOverTime = [UIColor colorWithRed: 0.946 green: 0.068 blue: 0.068 alpha: 1];
    UIColor* g_LowPressureColor = [UIColor colorWithRed: 0.389 green: 0.8 blue: 0.32 alpha: 1];
    UIColor* g_MediumPressureColor = [UIColor colorWithRed: 0.972 green: 0.924 blue: 0 alpha: 1];
    UIColor* g_HighPressureColor = [UIColor colorWithRed: 1 green: 0.106 blue: 0 alpha: 1];
    UIColor* g_GaugeNormal = [UIColor colorWithRed: 0 green: 0 blue: 0 alpha: 1];
    UIColor* g_white = [UIColor colorWithRed: 1 green: 0.998 blue: 0.998 alpha: 1];
    UIColor* g_clear = [UIColor colorWithRed: 1 green: 1 blue: 1 alpha: 0];

    //// Variable Declarations
    CGFloat g_midSeconds = (g_minSeconds + g_maxSeconds) / 2.0;
    CGFloat g_pressure = g_elapsedSeconds / (g_maxSeconds + 30);
    CGFloat g_ppressure = g_pressure < 0 ? 0 : (g_pressure > 1 ? 1 : g_pressure);
    CGFloat g_angle = -270 * g_ppressure + 135;
    UIColor* g_limitingColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_minSeconds ? g_GaugeNormal : (g_elapsedSeconds < g_midSeconds ? g_LowPressureColor : (g_elapsedSeconds < g_maxSeconds ? g_MediumPressureColor : g_HighPressureColor)));
    UIColor* g_overTimeColor = g_elapsedSeconds <= 0 ? g_clear : (g_elapsedSeconds < g_maxSeconds + 30 ? g_GaugeOutline : g_GaugeOutlineOverTime);
    UIColor* g_limitingFill = g_elapsedSeconds <= 0 ? g_clear : g_white;

    //// Perimeter Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);

    UIBezierPath* perimeterPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-24, -24, 48, 48)];
    [g_limitingFill setFill];
    [perimeterPath fill];
    [g_limitingColor setStroke];
    perimeterPath.lineWidth = 2;
    [perimeterPath stroke];

    CGContextRestoreGState(context);


    //// Bezier 5 Drawing
    UIBezierPath* bezier5Path = UIBezierPath.bezierPath;
    [bezier5Path moveToPoint: CGPointMake(35, 41.39)];
    [bezier5Path addCurveToPoint: CGPointMake(33.58, 42.07) controlPoint1: CGPointMake(35, 41.39) controlPoint2: CGPointMake(33.89, 41.91)];
    [bezier5Path addCurveToPoint: CGPointMake(16.51, 41.83) controlPoint1: CGPointMake(28.28, 44.72) controlPoint2: CGPointMake(21.74, 44.64)];
    [bezier5Path addCurveToPoint: CGPointMake(15.5, 41.11) controlPoint1: CGPointMake(16.19, 41.66) controlPoint2: CGPointMake(15.5, 41.11)];
    [bezier5Path addLineToPoint: CGPointMake(16.39, 40.13)];
    [bezier5Path addLineToPoint: CGPointMake(17.51, 39)];
    [bezier5Path addCurveToPoint: CGPointMake(18.67, 39.45) controlPoint1: CGPointMake(17.51, 39) controlPoint2: CGPointMake(18.17, 39.23)];
    [bezier5Path addCurveToPoint: CGPointMake(31.48, 39.6) controlPoint1: CGPointMake(21.62, 40.75) controlPoint2: CGPointMake(28.44, 40.65)];
    [bezier5Path addCurveToPoint: CGPointMake(33.12, 39.07) controlPoint1: CGPointMake(31.86, 39.47) controlPoint2: CGPointMake(33.12, 39.07)];
    [bezier5Path addLineToPoint: CGPointMake(34.08, 40.14)];
    [bezier5Path addLineToPoint: CGPointMake(35, 41.39)];
    [bezier5Path closePath];
    [g_overTimeColor setFill];
    [bezier5Path fill];
    [g_limitingColor setStroke];
    bezier5Path.lineWidth = 2;
    [bezier5Path stroke];


    //// ticks Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 23, 25);

    UIBezierPath* ticksPath = UIBezierPath.bezierPath;
    [ticksPath moveToPoint: CGPointMake(16.34, 7.5)];
    [ticksPath addCurveToPoint: CGPointMake(13.67, -12.6) controlPoint1: CGPointMake(19.93, 1.12) controlPoint2: CGPointMake(19.04, -7.16)];
    [ticksPath addCurveToPoint: CGPointMake(-9.67, -12.6) controlPoint1: CGPointMake(7.22, -19.13) controlPoint2: CGPointMake(-3.22, -19.13)];
    [ticksPath addCurveToPoint: CGPointMake(-12.37, 7.44) controlPoint1: CGPointMake(-15.03, -7.17) controlPoint2: CGPointMake(-15.93, 1.06)];
    [g_overTimeColor setStroke];
    ticksPath.lineWidth = 4;
    CGFloat ticksPattern[] = {1, 5};
    [ticksPath setLineDash: ticksPattern count: 2 phase: -8];
    [ticksPath stroke];

    CGContextRestoreGState(context);


    //// Bezier Drawing
    UIBezierPath* bezierPath = UIBezierPath.bezierPath;
    [bezierPath moveToPoint: CGPointMake(34.27, 34.78)];
    [bezierPath addLineToPoint: CGPointMake(35.14, 35.64)];
    [bezierPath addLineToPoint: CGPointMake(37.36, 37.82)];
    [bezierPath addLineToPoint: CGPointMake(38.21, 38.66)];
    [bezierPath addCurveToPoint: CGPointMake(39.3, 37.82) controlPoint1: CGPointMake(38.21, 38.66) controlPoint2: CGPointMake(38.76, 38.37)];
    [bezierPath addCurveToPoint: CGPointMake(41.55, 34.84) controlPoint1: CGPointMake(40.1, 37.01) controlPoint2: CGPointMake(41.04, 35.74)];
    [bezierPath addCurveToPoint: CGPointMake(38.36, 11.67) controlPoint1: CGPointMake(45.66, 27.46) controlPoint2: CGPointMake(44.6, 17.95)];
    [bezierPath addCurveToPoint: CGPointMake(11.14, 11.67) controlPoint1: CGPointMake(30.84, 4.11) controlPoint2: CGPointMake(18.66, 4.11)];
    [bezierPath addCurveToPoint: CGPointMake(8.37, 35.56) controlPoint1: CGPointMake(4.7, 18.16) controlPoint2: CGPointMake(3.77, 28.09)];
    [bezierPath addCurveToPoint: CGPointMake(11.12, 39) controlPoint1: CGPointMake(9.14, 36.81) controlPoint2: CGPointMake(11.12, 39)];
    [bezierPath addCurveToPoint: CGPointMake(12.19, 38) controlPoint1: CGPointMake(11.12, 39) controlPoint2: CGPointMake(11.87, 38.31)];
    [bezierPath addCurveToPoint: CGPointMake(14.62, 35.69) controlPoint1: CGPointMake(13.37, 36.91) controlPoint2: CGPointMake(14.13, 36.17)];
    [bezierPath addCurveToPoint: CGPointMake(15.48, 34.78) controlPoint1: CGPointMake(15.38, 34.93) controlPoint2: CGPointMake(15.48, 34.78)];
    [bezierPath addCurveToPoint: CGPointMake(14.42, 33.58) controlPoint1: CGPointMake(15.48, 34.78) controlPoint2: CGPointMake(14.75, 34)];
    [bezierPath addCurveToPoint: CGPointMake(15.43, 15.83) controlPoint1: CGPointMake(10.31, 28.32) controlPoint2: CGPointMake(10.62, 20.67)];
    [bezierPath addCurveToPoint: CGPointMake(34.23, 15.83) controlPoint1: CGPointMake(20.63, 10.6) controlPoint2: CGPointMake(29.04, 10.6)];
    [bezierPath addCurveToPoint: CGPointMake(35.08, 33.88) controlPoint1: CGPointMake(39.14, 20.76) controlPoint2: CGPointMake(39.44, 28.62)];
    [bezierPath addCurveToPoint: CGPointMake(34.27, 34.78) controlPoint1: CGPointMake(34.83, 34.19) controlPoint2: CGPointMake(34.27, 34.78)];
    [bezierPath closePath];
    [g_limitingColor setStroke];
    bezierPath.lineWidth = 2;
    [bezierPath stroke];


    //// gaugeArm Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);
    CGContextRotateCTM(context, -g_angle * M_PI / 180);

    UIBezierPath* gaugeArmPath = UIBezierPath.bezierPath;
    [gaugeArmPath moveToPoint: CGPointMake(-2.91, 7)];
    [gaugeArmPath addLineToPoint: CGPointMake(3.09, 7)];
    [gaugeArmPath addLineToPoint: CGPointMake(3.09, -15.37)];
    [gaugeArmPath addLineToPoint: CGPointMake(0.23, -18)];
    [gaugeArmPath addLineToPoint: CGPointMake(-2.91, -15.37)];
    [gaugeArmPath addLineToPoint: CGPointMake(-2.91, 7)];
    [gaugeArmPath closePath];
    [g_overTimeColor setFill];
    [gaugeArmPath fill];
    [g_overTimeColor setStroke];
    gaugeArmPath.lineWidth = 2;
    [gaugeArmPath stroke];

    CGContextRestoreGState(context);


    //// turnGear Drawing
    CGContextSaveGState(context);
    CGContextTranslateCTM(context, 25, 25);

    UIBezierPath* turnGearPath = [UIBezierPath bezierPathWithOvalInRect: CGRectMake(-5.5, -5.5, 11, 11)];
    [g_limitingFill setFill];
    [turnGearPath fill];
    [g_overTimeColor setStroke];
    turnGearPath.lineWidth = 2;
    [turnGearPath stroke];

    CGContextRestoreGState(context);
}

#pragma mark Generated Images

+ (UIImage*)imageOfGauge50WithG_minSeconds: (CGFloat)g_minSeconds g_maxSeconds: (CGFloat)g_maxSeconds g_elapsedSeconds: (CGFloat)g_elapsedSeconds;
{
    UIGraphicsBeginImageContextWithOptions(CGSizeMake(50, 50), NO, 0.0f);
    [TMTimerStyleKit drawGauge50WithG_minSeconds: g_minSeconds g_maxSeconds: g_maxSeconds g_elapsedSeconds: g_elapsedSeconds];
    UIImage* imageOfGauge50 = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();

    return imageOfGauge50;
}

@end
